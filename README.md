# Sescrifin
 Sescrifin stands for semi scriptable file index. Make a list of files, and then run the program on the list of files. It'll make an archive containing all the files in the list, and a file listing where all of the files came from. You can then take this file, run the program on it again on another system (or the same one), and it'll copy all of the files to their original locations, creating any directories needed. 

##  Use Case
 OK, why would you use Sescrifin over git or just copy paste? For system-wide config files, like files in the /etc/ directory. 

##  How It Works
 The Sescrifin program has two modes: generation and read. 

 In generation mode, you need to specify an input file and an output file. Generation mode will assume the input file is an index; a list of file paths and variables, it will then copy all the files specified in the index into the output file, along with a copy of the index which can be used later to put the files back. 

 Read mode will assume the input file is an archive file generated by Sescrifin. Read mode does **not** need an output file, as all of the file locations will be specified within the tar file generated by Sescrifin. Read mode must be run as root. In read mode, Sescrifin will use the index stored in the tar file to copy all of the files back to their original\* locations, creating any needed directories. 

\*if the variables change, the locations will change.

##  CLI Flags

|Main Flag|Abridged Flag|Description / Use|~~
|---|---|---|
|help | -h | Print this text to the standard output.|~~
|input | -i | The following argument will be the input file.|~~
|output | -o | The following argument will be the output file.|~~
|generate | -g | Set the mode to generation.|~~
|read | -r | Set the mode to read.|~~
|config | -c   | Override the default config file, setting it to the next argument.|


##  The Index's Variables, Filepaths, and General Format
 The index is the file used to tell Sescrifin what files to get. 

 You can define a variable with "var" followed by a dollar sign, and the name of the variable, then a new line. The content of all variables will be inputted by the user at runtime. A variable can contain **only** alphabetic characters; "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ". For example, defining a variable with the name "$variable" would look like this:

var $variable

 Any other line will be interpreted as a file path. Any dollar sign and backslash must be preceeded by a backslash. To insert a variable into a file path, you'd need a dollar sign followed by the name of the variable. Using this variable in a file path would look like this: 

/path/to/a/file/$variable/file

If the contents of the variable were "example", this line would be interpreted as:

/path/to/a/file/example/file

 Note that variables must be re-defined at runtime, so that if you wanted files in a different directory on a different system, you could set the directory to be a variable and type the desired directory at runtime. 


##  Config File
 The config file is, by default, assumed to be located at ~/.config/sescrifin.conf, but this can be changed with the -c flag. The default location can be changed with the DEFAULT\_CONFIG\_LOCATION variable. 


 The config file is used to set variables for Sescrifin, so you won't be prompted to enter them every time. Importantly, the contents of the config file can differ across systems, and therefore, variables can differ across systems. 

 To define a variable in the Sescrifin config file(which is, at the moment, all you *can* do), you type, on a new line, a dollar sign followed by the name of the variable, an equal sign, and the contents of the variable. If, for example you wanted a variable named **$varOne**. You'd enter: 

**$varOne = *(content here)***
(the whitespace is optional)

 OK, now what for the content? Well, unlike in the index files themselves, we can use basic logic in the config file! To include the content of another variable, you type the name of the variable preceeded by a dollar sign. So, if you wanted to set the contents of variable **$varOne** to the contents of  **$OtherVar**, assuming the var "OtherVar" was previously defined, you'd enter: 

**$varOne = (ERROR; VAR NOT FOUND)

 In order to enter text, you just need to type the desired text within quotes (the quotes themselves won't be included in the variable's contents). So, to assign "Hello, World!" to the variable **$varOne**, you'd enter: 

**$varOne = "Hello, World!"**

 Note that in order to include a quotation mark in the content of a variable you preceed that quotation mark with a backslash, and in order to include a backslash, you preceed that with another backslash. So, in order to assign ""I sure do love backs\\ashes!"" to the variable **$varOne**, you'd enter: 

**$varOne = "\\"I sure do love backs\\\\ashes!\\""**

 Cool, but what if you wanted to combine two values? With the concatenation operator, of course! The concatenation operator is the ampersand(&), so to assign "Hello, World!" followed by the contents of the variable **$OtherVar** to the variable **$varOne** you'd enter: 

**$varOne = "Hello, World!" & $OtherVar**

 Note that you can use multiple concatenation operations in a single variable decleration 

 Great! But ensuring your configuration is dynamic is the whole point. So, you can invoke shell commands within the configuration files. To do so, take a command(for this example we'll use "echo hello"), and surround the arguments to the command with parenthesis("echo (hello)"). Then surround the new command with curly braces("{echo (hello)}"). This means you can't use more advanced shell commands like pipes, but you *can* invoke a shell script, so do that if you need more advanced shell features. OK, so if you wanted to get the location of the home directory, and a file within it named "file". You'd do as follows: 

**

$filename = "file"
$FileInHome = {echo (~)} & "/" & $filename
**

 Now, the variable **$FileInHome** has the contents "/home/(username)/file", and it can be used within an index file. and that's all for the config file 

**